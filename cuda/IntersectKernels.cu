#include "IntersectKernels.hpp"

namespace mcvine
{

    namespace gpu
    {

        namespace kernels
        {

            __device__ void intersectRectangle(float &ts, Vec3<float> &pts,
                                               const Vec3<float> &orig, float zdiff,
                                               const Vec3<float> &vel,
                                               const float A, const float B,
                                               const int key, int &off)
            {
                /* The system is temporarily shifted so that the plane potentially
                 * being intersected lies along a coordinate plane (i.e. if the
                 * shift is in z, the system is shifted so that the rectangle lies
                 * entirely in the XY-plane. This shift is represented by c.
                 * The time is then calculated using kinematics on the
                 * shifted system. 
                 */
                float c = orig[2-key] - zdiff;
                float t = (0-c)/vel[2-key];
                /* From this point on, the system is no longer shifted.
                 * The intersection point is calculated using basic kinematics.
                 */
                Vec3<float> pt = orig + vel*t;
                /* These nested if-statements convert the key into a pair of
                 * values that are used to ensure the intersection point is
                 * within the rectangle.
                 */
                int n1 = (key == 0 || key == 1) ? 0 : 1;
                int n2 = (key == 1 || key == 2) ? 2 : 1;
                // This if-statement ensures the intersection is within the rectangle.
                if (fabsf(pt[n1]) < (A/2) && fabsf(pt[n2]) < (B/2))
                {
                    if (off < 2)
                    {
                        pts = pt;
                        // Increases off to prevent data overwrite.
                        off++;
                    }
                    ts = t;
                }
                /* If the intersection coordinates do not fall within the rectangle,
                 * a time of -1 is assigned to the function call's element in ts.
                 * Additionally, no intersection coordinates are stored in pts.
                 */
                else
                {
                    ts = -1;
                }
            }

            __device__ void intersectCylinderSide(float *ts, Vec3<float> *pts,
                                                  const Vec3<float> &orig,
                                                  const Vec3<float> &vel,
                                                  const float r, const float h, 
                                                  int &offset)
            {
                /* Calculate the a, b, and c parameters for the quadratic formula.
                 * The parameters are generated by substituting the x and y
                 * components of the neutron's ray equation into the equation for
                 * a circular Cylinder. The final equation is:
                 *    (vx^2 + vy^2)*t^2 + 2(x*vx + y*vy)*t + (x^2 + y^2 + r^2) = 0
                 */ 
                float a = vel[0]*vel[0] + vel[1]*vel[1];
                float b = 2*(orig[0]*vel[0] + orig[1]*vel[1]);
                float c = orig[0]*orig[0] + orig[1]*orig[1] - r*r; 
                float t0, t1;
                /* If the solveQuadratic function returns false, there are no
                 * valid intersection times. As a result, there is no
                 * intersection with the Cylinder's side, and the corresponding
                 * times are set accordingly.
                 */
                if (!solveQuadratic(a, b, c, t0, t1))
                {
                    ts[0] = -1;
                    ts[1] = -1;
                }
                /* In this case, there is a valid intersection with the Cylinder's 
                 * side. However, since t0 < 0 and since t0 is guaranteed to be
                 * less than t1 (see solveQuadratic), there is only one valid
                 * intersection time.
                 */
                else if (t0 < 0)
                {
                    /* ts[4*index + 3] stores the time of the second intersection
                     * between the neutron and the side of the Cylinder. Since a
                     * second intersection is not possible in this case, this element
                     * of ts is given a default value of -1.
                     */
                    ts[1] = -1;
                    /* The neutron only intersects the side of the Cylinder 
                     * if the absolute value of the Z-coordinate of the intersection
                     * point is less than h/2.
                     */
                    if (fabsf(orig[2]+vel[2]*t1) < h/2)
                    {
                        ts[0] = t1;
                        // See intersectRectangle
                        if (offset < 2)
                        {
                            pts[offset] = orig + (vel*t1);
                            offset++;
                        }
                    }
                    else
                    {
                        ts[0] = -1;
                    }
                }
                // In this case, there are two valid intersection times.
                else
                {
                    // i is used to track the offset for ts
                    int i = 0;
                    if (fabsf(orig[2]+vel[2]*t0) < h/2)
                    {
                        ts[i] = t0;
                        i++;
                        if (offset < 2)
                        {
                            pts[offset] = orig + (vel*t0);
                            offset++;
                        }
                    }
                    if (fabsf(orig[2]+vel[2]*t1) < h/2)
                    {
                        ts[i] = t1;
                        i++;
                        if (offset < 2)
                        {
                            pts[offset] = orig + (vel*t1);
                            offset++;
                        }
                    }
                    /* If i < 2, at least one time was not set in ts.
                     * This if-statement will set the time of these unset
                     * elements to -1.
                     */
                    if (i < 2)
                    {
                        for (int j = i; j < 2; j++)
                        {
                            ts[j] = -1;
                        }
                    }
                }
                // Again used to prevent memory corruption
            }

            __device__ void intersectCylinderTopBottom(float *ts, Vec3<float> *pts,
                                                       const Vec3<float> &orig,
                                                       const Vec3<float> &vel,
                                                       const float r, const float h,
                                                       int &offset)
            {
                // Calculates values needed to evaluate and validate the time.
                float r2 = r*r;
                float hh = h/2;
                Vec3<float> faceint;
                /* Time is calculated by dividing the Z-distance the neutron has
                 * to travel to reach the Z-coordinate of the top of the Cylinder
                 * by the Z component of the neutron's velocity.
                 */
                float t = (hh-orig[2])/vel[2];
                /* Uses basic kinematics to determine the X and Y 
                 * coordinates of the potential intersection point.
                 */
                faceint = orig + (vel * t);
                /* If the intersection point is a valid solution to the
                 * equation defining the circular top of the Cylinder, 
                 * the time and intersection coordinates are stored in
                 * ts and pts respectively.
                 */
                if (faceint[0]*faceint[0] + faceint[1]*faceint[1] <= r2)
                {
                    ts[0] = t;
                    if (offset < 2)
                    {
                        pts[offset] = faceint;
                        offset++;
                    }
                }
                // Otherwise, the time is stored as -1.
                else
                {
                    ts[0] = -1;
                }
                // Repeat the above step for the bottom face of the Cylinder.
                t = (-hh-orig[2])/vel[2];
                faceint = orig + (vel * t);
                if (faceint[0]*faceint[0] + faceint[1]*faceint[1] <= r2)
                {
                    ts[1] = t;
                    if (offset < 2)
                    {
                        pts[offset] = faceint;
                        offset++;
                    }
                }
                else
                {
                    ts[1] = -1;
                }
            }

            /* This function calculates the intersection point and time
             * for a neutron and a triangle (in three dimensions).
             * It is an implementation of the Moller-Trumbore Ray-Triangle
             * Intersection algorithm.
             * Note that this algorithm is not the same as the one used
             * currently in McVine.
             */
            __device__ void intersectTriangle(float &ts, Vec3<float> *pts,
                                              const Vec3<float> &orig,
                                              const Vec3<float> &vel,
                                              const Vec3<float> &a,
                                              const Vec3<float> &b,
                                              const Vec3<float> &c,
                                              int &off)
            {   
                const float EPSILON = 1e-7;
                /* edge1 is the vector corresponding to the edge of the
                 *     triangle between vertices a and b.
                 * edge2 is the vector corresponding to the edge of the
                 *     triangle between vertices a and c.
                 * p is the cross product of neutron velocity and edge2.
                 * s is the vector connecting the neutron's initial position
                 *     (orig) and vertex a.
                 * q is the cross product between s and edge1. 
                 */
                Vec3<float> edge1, edge2, p, s, q;
                /* denom is the dot product of edge1 and p. It is used to determine
                 *     if the neutron's ray is parallel to the triangle.
                 * frac is the fraction used in the calculation of t, u, and v.
                 * u and v are the Barycentric Coordinates used to represent the
                 *     intersection point in the Moller-Trumbore algorithm.
                 */
                float denom, frac, u, v;
                edge1 = b - a;
                edge2 = c - a;
                p = vel * edge2;
                denom = edge1 | p;
                /* If denom is close to zero, the ray representing the neutron
                 * is parallel to the triangle. As a result, the time is set to a
                 * default no-intersection value of -1, and the function ends.
                 */
                if (fabsf(denom) < EPSILON)
                {
                    ts = -1;
                    return;
                }
                frac = 1/denom;
                s = orig - a;
                /* The Moller-Trumbore algorithm says that t, u, and v are calculated
                 * by the following equations:
                 *     u = 1/(dot(p, edge1)) * (dot(p, s))
                 *     v = 1/(dot(p, edge1)) * (dot(q, vel))
                 *     t = 1/(dot(p, edge1)) * (dot(q, edge2))
                 * The code below calculates these values using these equations.
                 */
                u = frac * (s | p);
                /* Barycentric coordinates must be between 0 and 1 for a point to lie
                 * within the triangle. Therefore, if u is not in this range,
                 * there is no intersection.
                 */
                if (u < 0 || u > 1)
                {
                    ts = -1;
                    return;
                }
                q = s * edge1;
                v = frac * (vel | q);
                /* The same point about the range of u applies to v.
                 * Additionally, the point is within the triangle if and only if
                 * u + v <= 1.
                 * If either of these conditions are not met, there is no intersection.
                 */
                if (v < 0 || u+v > 1)
                {
                    ts = -1;
                    return;
                }
                float t = frac * (edge2 | q);
                /*if (t < EPSILON)
                {
                    ts[5*index + off1] = -1;
                    return;
                }*/
                /* If the code gets to this point, there is a valid intersection,
                 * and the intersection data is stored.
                 */
                ts = t;
                if (off < 2)
                {
                    pts[off] = orig + vel*t;
                    off++;
                }
            }

            // Data is going to be broken down into groupings in intersect kernel.
            __device__ void intersectBox(Vec3<float>& origins,
                                         Vec3<float>& vel,
                                         const float *shapeData,
                                         float* ts, Vec3<float>* pts)
            {
                /* The offset variable is used to ensure only
                 * 2 intersection points are recorded.
                 */
                int offset = 0;
                /* If the neutron does not move in the Z-direction, there will
                 * never be an intersection with the top or bottom. So,
                 * the times for top and bottom intersection are set to -1.
                 * Otherwise, the intersectRectangle function is used to
                 * calculate any potential intersection times and points.
                 */
                if (vel[2] != 0)
                {
                    intersectRectangle(ts[0], pts[offset], origins, shapeData[2]/2, vel, shapeData[0], shapeData[1], 0, offset);
                    intersectRectangle(ts[1], pts[offset], origins, -shapeData[2]/2, vel, shapeData[0], shapeData[1], 0, offset);
                }
                else
                {
                    ts[0] = -1;
                    ts[1] = -1;
                }
                /* If the neutron does not move in the X-direction, there will
                 * never be an intersection with the sides parallel to the YZ plane.
                 * So, the times for these intersections are set to -1.
                 * Otherwise, the intersectRectangle function is used to
                 * calculate any potential intersection times and points.
                 */
                if (vel[0] != 0)
                {
                    intersectRectangle(ts[2], pts[offset], origins, shapeData[0]/2, vel, shapeData[1], shapeData[2], 2, offset);
                    intersectRectangle(ts[3], pts[offset], origins, -shapeData[0]/2, vel, shapeData[1], shapeData[2], 2, offset);
                }
                else
                {
                    ts[2] = -1;
                    ts[3] = -1;
                }
                /* If the neutron does not move in the Y-direction, there will
                 * never be an intersection with the sides parallel to the XZ plane.
                 * So, the times for these intersections are set to -1.
                 * Otherwise, the intersectRectangle function is used to
                 * calculate any potential intersection times and points.
                 */
                if (vel[1] != 0)
                {
                    intersectRectangle(ts[4], pts[offset], origins, shapeData[1]/2, vel, shapeData[0], shapeData[2], 1, offset);
                    intersectRectangle(ts[5], pts[offset], origins, -shapeData[1]/2, vel, shapeData[0], shapeData[2], 1, offset);
                }
                else
                {
                    ts[4] = -1;
                    ts[5] = -1;
                }
            }

            __device__ void intersectCylinder(Vec3<float> &origins, Vec3<float> &vel,
                                              const float *shapeData,
                                              float *ts, Vec3<float> *pts)
            {
                /* The offset variable is used to ensure only
                 * 2 intersection points are recorded.
                 */
                int offset = 0;
                /* The actual intersection calculations are carried out
                 * by these two helper functions.
                 */
                intersectCylinderTopBottom(&(ts[0]), pts, origins, vel, shapeData[0], shapeData[1], offset);
                intersectCylinderSide(&(ts[2]), pts, origins, vel, shapeData[0], shapeData[1], offset);
            }

            __device__ void intersectPyramid(Vec3<float> &origins, Vec3<float> &vel,
                                             const float *shapeData,
                                             float *ts, Vec3<float> *pts)
            {
                /* The offset variable is used to ensure only
                 * 2 intersection points are recorded.
                 */
                int offset = 0;
                /* If the neutron doesn't move in the Z-direction, it will
                 * never intersect the Pyramid's base. If it might intersect,
                 * the intersectRectangle function is used to determine any
                 * intersection point.
                 */
                if (vel[2] != 0)
                {
                    intersectRectangle(ts[0], pts[offset], origins, -shapeData[2], vel, shapeData[0], shapeData[1], 0, offset);
                }
                else
                {
                    ts[0] = -1;
                }
                /* These calls to intersectTriangle determine if there are
                 * any intersections between the neutron and the triangular
                 * faces of the Pyramid.
                 */
                intersectTriangle(ts[1], pts,
                                  origins,
                                  vel,
                                  Vec3<float>(0, 0, 0),
                                  Vec3<float>(shapeData[0]/2, shapeData[1]/2, -shapeData[2]),
                                  Vec3<float>(shapeData[0]/2, -shapeData[1]/2, -shapeData[2]),
                                  offset);
                intersectTriangle(ts[2], pts,
                                  origins,
                                  vel,
                                  Vec3<float>(0, 0, 0),
                                  Vec3<float>(shapeData[0]/2, -shapeData[1]/2, -shapeData[2]),
                                  Vec3<float>(-shapeData[0]/2, -shapeData[1]/2, -shapeData[2]),
                                  offset);
                intersectTriangle(ts[3], pts,
                                  origins,
                                  vel,
                                  Vec3<float>(0, 0, 0),
                                  Vec3<float>(-shapeData[0]/2, -shapeData[1]/2, -shapeData[2]),
                                  Vec3<float>(-shapeData[0]/2, shapeData[1]/2, -shapeData[2]),
                                  offset);
                intersectTriangle(ts[4], pts,
                                  origins,
                                  vel,
                                  Vec3<float>(0, 0, 0),
                                  Vec3<float>(-shapeData[0]/2, shapeData[1]/2, -shapeData[2]),
                                  Vec3<float>(shapeData[0]/2, shapeData[1]/2, -shapeData[2]),
                                  offset);
            }

            __device__ void intersectSphere(Vec3<float> &origins, Vec3<float> &vel,
                                            const float *shapeData,
                                            float *ts, Vec3<float> *pts)
            {
                /* Calculates the a, b, and c parameters needed for the
                 * quadratic formula. These parameters are defined by the
                 * equation that is developed by plugging the components
                 * of the ray equation for a neutron
                 * (<x,y,z> = <x0,y0,z0>+t*<vx,vy,vz>) into the equation of
                 * a Sphere.
                 */
                float a = (vel | vel);
                float b = 2*(origins | vel);
                float c = (origins | origins);
                c -= shapeData[0]*shapeData[0];
                /* The solveQuadratic function is used to calculate the
                 * two potential intersection times. If the function
                 * returns false, the neutron does not intersect, and the
                 * corresponding values in ts are set to -1.
                 */
                float t0, t1;
                if (!solveQuadratic(a, b, c, t0, t1))
                {
                    ts[0] = -1;
                    ts[1] = -1;
                    return;
                }
                /* If solveQuadratic returns true, the times are stored in 
                 * ts, and the intersection points are calculated and stored
                 * in pts.
                 */
                else
                {
                    if (t0 < 0)
                    {
                        ts[0] = -1;
                    }
                    else
                    {
                        ts[0] = t0;
                        pts[0] = origins + (vel * t0);
                    }
                    if (t1 < 0)
                    {
                        ts[1] = -1;
                    }
                    else
                    {
                        ts[1] = t1;
                        pts[1] = origins + (vel * t1);
                    }
                }
            }

            __global__ void intersect(const int shapeKey, Vec3<float> *origins,
                                      Vec3<float> *vel, const float *shapeData,
                                      const int N,
                                      float *ts, Vec3<float> *pts)
            {
                int index = blockIdx.x * blockDim.x + threadIdx.x;
                if (index < N)
                {
                    switch(shapeKey)
                    {
                        case 0:
                            intersectBox(origins[index], vel[index], shapeData,
                                         &(ts[6*index]), &(pts[2*index]));
                            break;
                        case 1:
                            intersectCylinder(origins[index], vel[index], shapeData,
                                              &(ts[4*index]), &(pts[2*index]));
                            break;
                        case 2:
                            intersectPyramid(origins[index], vel[index], shapeData,
                                             &(ts[5*index]), &(pts[2*index]));
                            break;
                        case 3:
                            intersectSphere(origins[index], vel[index], shapeData,
                                            &(ts[2*index]), &(pts[2*index]));
                            break;
                        default:
                            printf("Error: Invalid value for \"shapeKey\" (must be in range 0-3, inclusive).\nExiting GPU.\n");
                            asm("trap;");
                    }
                }
                __syncthreads();
            }

        }

    }

}
