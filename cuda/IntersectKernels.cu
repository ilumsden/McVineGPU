#include "IntersectKernels.hpp"

__device__ void intersectRectangle(float* ts, Vec3<float>* pts,
                                   const Vec3<float> &orig, float zdiff,
                                   const Vec3<float> &vel,
                                   const float A, const float B,
                                   const int key, const int groupSize, 
                                   const int off1, int &off2)
{
    /* The system is temporarily shifted so that the plane potentially
     * being intersected lies along a coordinate plane (i.e. if the
     * shift is in z, the system is shifted so that the rectangle lies
     * entirely in the XY-plane. This shift is represented by c.
     * The time is then calculated using kinematics on the
     * shifted system. 
     */
    float c = orig[2-key] - zdiff;
    float t = (0-c)/vel[2-key];
    /* From this point on, the system is no longer shifted.
     * The intersection point is calculated using basic kinematics.
     */
    Vec3<float> pt = orig + vel*t;
    int index = blockIdx.x * blockDim.x + threadIdx.x;
    /* These nested if-statements convert the key into a pair of
     * values that are used to ensure the intersection point is
     * within the rectangle.
     */
    int n1 = (key == 0 || key == 1) ? 0 : 1;
    int n2 = (key == 1 || key == 2) ? 2 : 1;
    // This if-statement ensures the intersection is within the rectangle.
    if (fabsf(pt[n1]) < (A/2) && fabsf(pt[n2]) < (B/2))
    {
        if (off2 < 2)
        {
            pts[2*index + off2] = pt;
            // Increases off2 to prevent data overwrite.
            off2++;
        }
        ts[off1 + index*groupSize] = t;
    }
    /* If the intersection coordinates do not fall within the rectangle,
     * a time of -1 is assigned to the function call's element in ts.
     * Additionally, no intersection coordinates are stored in pts.
     */
    else
    {
        ts[off1 + index*groupSize] = -1;
    }
}

__device__ void intersectCylinderSide(float *ts, Vec3<float> *pts,
                                      const Vec3<float> &orig,
                                      const Vec3<float> &vel,
                                      const float r, const float h, 
                                      int &offset)
{
    /* Calculate the a, b, and c parameters for the quadratic formula.
     * The parameters are generated by substituting the x and y
     * components of the neutron's ray equation into the equation for
     * a circular Cylinder. The final equation is:
     *    (vx^2 + vy^2)*t^2 + 2(x*vx + y*vy)*t + (x^2 + y^2 + r^2) = 0
     */ 
    float a = vel[0]*vel[0] + vel[1]*vel[1];
    float b = 2*(orig[0]*vel[0] + orig[1]*vel[1]);
    float c = orig[0]*orig[0] + orig[1]*orig[1] - r*r; 
    float t0, t1;
    int index = blockIdx.x * blockDim.x + threadIdx.x;
    /* If the solveQuadratic function returns false, there are no
     * valid intersection times. As a result, there is no
     * intersection with the Cylinder's side, and the corresponding
     * times are set accordingly.
     */
    if (!solveQuadratic(a, b, c, t0, t1))
    {
        ts[4*index + 2] = -1;
        ts[4*index + 3] = -1;
    }
    /* In this case, there is a valid intersection with the Cylinder's 
     * side. However, since t0 < 0 and since t0 is guaranteed to be
     * less than t1 (see solveQuadratic), there is only one valid
     * intersection time.
     */
    else if (t0 < 0)
    {
        /* ts[4*index + 3] stores the time of the second intersection
         * between the neutron and the side of the Cylinder. Since a
         * second intersection is not possible in this case, this element
         * of ts is given a default value of -1.
         */
        ts[4*index + 3] = -1;
        /* The neutron only intersects the side of the Cylinder 
         * if the absolute value of the Z-coordinate of the intersection
         * point is less than h/2.
         */
        if (fabsf(orig[2]+vel[2]*t1) < h/2)
        {
            ts[4*index + 2] = t1;
            // See intersectRectangle
            if (offset < 2)
            {
                pts[2*index + offset] = orig + (vel*t1);
                offset++;
            }
        }
        else
        {
            ts[4*index + 2] = -1;
        }
    }
    // In this case, there are two valid intersection times.
    else
    {
        // i is used to track the offset for ts
        int i = 2;
        if (fabsf(orig[2]+vel[2]*t0) < h/2)
        {
            ts[4*index + i] = t0;
            i++;
            if (offset < 2)
            {
                pts[2*index + offset] = orig + (vel*t0);
                offset++;
            }
        }
        if (fabsf(orig[2]+vel[2]*t1) < h/2)
        {
            ts[4*index + i] = t1;
            i++;
            if (offset < 2)
            {
                pts[2*index + offset] = orig + (vel*t1);
                offset++;
            }
        }
        /* If i < 4, at least one time was not set in ts.
         * This if-statement will set the time of these unset
         * elements to -1.
         */
        if (i < 4)
        {
            for (int j = i; j < 4; j++)
            {
                ts[4*index + j] = -1;
            }
        }
    }
    // Again used to prevent memory corruption
    __syncthreads();
}

__device__ void intersectCylinderTopBottom(//float *ts, float *pts,
                                           float *ts, Vec3<float> *pts,
                                           //float x, float y, float z,
                                           //float vx, float vy, float vz,
                                           const Vec3<float> &orig,
                                           const Vec3<float> &vel,
                                           const float r, const float h,
                                           int &offset)
{
    // Calculates values needed to evaluate and validate the time.
    float r2 = r*r;
    float hh = h/2;
    Vec3<float> faceint;
    int index = blockIdx.x * blockDim.x + threadIdx.x;
    /* Time is calculated by dividing the Z-distance the neutron has
     * to travel to reach the Z-coordinate of the top of the Cylinder
     * by the Z component of the neutron's velocity.
     */
    float t = (hh-orig[2])/vel[2];
    /* Uses basic kinematics to determine the X and Y 
     * coordinates of the potential intersection point.
     */
    faceint = orig + (vel * t);
    /* If the intersection point is a valid solution to the
     * equation defining the circular top of the Cylinder, 
     * the time and intersection coordinates are stored in
     * ts and pts respectively.
     */
    if (faceint[0]*faceint[0] + faceint[1]*faceint[1] <= r2)
    {
        ts[4*index] = t;
        if (offset < 2)
        {
            pts[2*index + offset] = faceint;
            offset++;
        }
    }
    // Otherwise, the time is stored as -1.
    else
    {
        ts[4*index] = -1;
    }
    // Repeat the above step for the bottom face of the Cylinder.
    t = (-hh-orig[2])/vel[2];
    faceint = orig + (vel * t);
    if (faceint[0]*faceint[0] + faceint[1]*faceint[1] <= r2)
    {
        ts[4*index + 1] = t;
        if (offset < 2)
        {
            pts[2*index + offset] = faceint;
            offset++;
        }
    }
    else
    {
        ts[4*index + 1] = -1;
    }
}

/* This function calculates the intersection point and time
 * for a neutron and a triangle (in three dimensions).
 * It is an implementation of the Moller-Trumbore Ray-Triangle
 * Intersection algorithm.
 * Note that this algorithm is not the same as the one used
 * currently in McVine.
 */
__device__ void intersectTriangle(float *ts, Vec3<float> *pts,
                                  const Vec3<float> &orig,
                                  const Vec3<float> &vel,
                                  const Vec3<float> &a,
                                  const Vec3<float> &b,
                                  const Vec3<float> &c,
                                  const int off1, int &off2)
{   
    int index = blockIdx.x * blockDim.x + threadIdx.x;
    const float EPSILON = 1e-7;
    /* edge1 is the vector corresponding to the edge of the
     *     triangle between vertices a and b.
     * edge2 is the vector corresponding to the edge of the
     *     triangle between vertices a and c.
     * p is the cross product of neutron velocity and edge2.
     * s is the vector connecting the neutron's initial position
     *     (orig) and vertex a.
     * q is the cross product between s and edge1. 
     */
    Vec3<float> edge1, edge2, p, s, q;
    /* denom is the dot product of edge1 and p. It is used to determine
     *     if the neutron's ray is parallel to the triangle.
     * frac is the fraction used in the calculation of t, u, and v.
     * u and v are the Barycentric Coordinates used to represent the
     *     intersection point in the Moller-Trumbore algorithm.
     */
    float denom, frac, u, v;
    edge1 = b - a;
    edge2 = c - a;
    p = vel * edge2;
    denom = edge1 | p;
    /* If denom is close to zero, the ray representing the neutron
     * is parallel to the triangle. As a result, the time is set to a
     * default no-intersection value of -1, and the function ends.
     */
    if (fabsf(denom) < EPSILON)
    {
        ts[5*index + off1] = -1;
        return;
    }
    frac = 1/denom;
    s = orig - a;
    /* The Moller-Trumbore algorithm says that t, u, and v are calculated
     * by the following equations:
     *     u = 1/(dot(p, edge1)) * (dot(p, s))
     *     v = 1/(dot(p, edge1)) * (dot(q, vel))
     *     t = 1/(dot(p, edge1)) * (dot(q, edge2))
     * The code below calculates these values using these equations.
     */
    u = frac * (s | p);
    /* Barycentric coordinates must be between 0 and 1 for a point to lie
     * within the triangle. Therefore, if u is not in this range,
     * there is no intersection.
     */
    if (u < 0 || u > 1)
    {
        ts[5*index + off1] = -1;
        return;
    }
    q = s * edge1;
    v = frac * (vel | q);
    /* The same point about the range of u applies to v.
     * Additionally, the point is within the triangle if and only if
     * u + v <= 1.
     * If either of these conditions are not met, there is no intersection.
     */
    if (v < 0 || u+v > 1)
    {
        ts[5*index + off1] = -1;
        return;
    }
    float t = frac * (edge2 | q);
    /*if (t < EPSILON)
    {
        ts[5*index + off1] = -1;
        return;
    }*/
    /* If the code gets to this point, there is a valid intersection,
     * and the intersection data is stored.
     */
    ts[5*index + off1] = t;
    if (off2 < 2)
    {
        pts[2*index + off2] = orig + vel*t;
        off2++;
    }
}

__global__ void intersectBox(Vec3<float>* origins,
                             Vec3<float>* vel,
                             const float X, const float Y, const float Z, 
                             const int N, float* ts, Vec3<float>* pts)
{
    int index = blockIdx.x * blockDim.x + threadIdx.x;
    // This is done to prevent excess threads from interfering in the code.
    if (index < N)
    {
        /* The offset variable is used to ensure only
         * 2 intersection points are recorded.
         */
        int offset = 0;
        /* If the neutron does not move in the Z-direction, there will
         * never be an intersection with the top or bottom. So,
         * the times for top and bottom intersection are set to -1.
         * Otherwise, the intersectRectangle function is used to
         * calculate any potential intersection times and points.
         */
        if (vel[index][2] != 0)
        {
            intersectRectangle(ts, pts, origins[index], Z/2, vel[index], X, Y, 0, 6, 0, offset);
            intersectRectangle(ts, pts, origins[index], -Z/2, vel[index], X, Y, 0, 6, 1, offset);
        }
        else
        {
            ts[index*6] = -1;
            ts[index*6 + 1] = -1;
        }
        /* If the neutron does not move in the X-direction, there will
         * never be an intersection with the sides parallel to the YZ plane.
         * So, the times for these intersections are set to -1.
         * Otherwise, the intersectRectangle function is used to
         * calculate any potential intersection times and points.
         */
        if (vel[index][0] != 0)
        {
            intersectRectangle(ts, pts, origins[index], X/2, vel[index], Y, Z, 2, 6, 2, offset);
            intersectRectangle(ts, pts, origins[index], -X/2, vel[index], Y, Z, 2, 6, 3, offset);
        }
        else
        {
            ts[index*6 + 2] = -1;
            ts[index*6 + 3] = -1;
        }
        /* If the neutron does not move in the Y-direction, there will
         * never be an intersection with the sides parallel to the XZ plane.
         * So, the times for these intersections are set to -1.
         * Otherwise, the intersectRectangle function is used to
         * calculate any potential intersection times and points.
         */
        if (vel[index][1] != 0)
        {
            intersectRectangle(ts, pts, origins[index], Y/2, vel[index], Z, X, 1, 6, 4, offset);
            intersectRectangle(ts, pts, origins[index], -Y/2, vel[index], Z, X, 1, 6, 5, offset);
        }
        else
        {
            ts[index*6 + 4] = -1;
            ts[index*6 + 5] = -1;
        }
    }
}

__global__ void intersectCylinder(Vec3<float> *origins, Vec3<float> *vel,
                                  const float r, const float h,
                                  const int N, float *ts, Vec3<float> *pts)
{
    int index = blockIdx.x * blockDim.x + threadIdx.x;
    // This is done to prevent excess threads from interfering in the code.
    if (index < N)
    {
        /* The offset variable is used to ensure only
         * 2 intersection points are recorded.
         */
        int offset = 0;
        /* The actual intersection calculations are carried out
         * by these two helper functions.
         */
        intersectCylinderTopBottom(ts, pts, origins[index], vel[index], r, h, offset);
        intersectCylinderSide(ts, pts, origins[index], vel[index], r, h, offset);
    }
}

__global__ void intersectPyramid(Vec3<float> *origins, Vec3<float> *vel,
                                 const float X, const float Y, const float H,
                                 const int N, float *ts, Vec3<float> *pts)
{
    int index = blockIdx.x * blockDim.x + threadIdx.x;
    // This is done to prevent excess threads from interfering in the code.
    if (index < N)
    {
        /* The offset variable is used to ensure only
         * 2 intersection points are recorded.
         */
        int offset = 0;
        /* If the neutron doesn't move in the Z-direction, it will
         * never intersect the Pyramid's base. If it might intersect,
         * the intersectRectangle function is used to determine any
         * intersection point.
         */
        if (vel[index][2] != 0)
        {
            intersectRectangle(ts, pts, origins[index], -H, vel[index], X, Y, 0, 5, 0, offset);
        }
        /* These calls to intersectTriangle determine if there are
         * any intersections between the neutron and the triangular
         * faces of the Pyramid.
         */
        intersectTriangle(ts, pts,
                          origins[index],
                          vel[index],
                          Vec3<float>(0, 0, 0),
                          Vec3<float>(X/2, Y/2, -H),
                          Vec3<float>(X/2, -Y/2, -H),
                          1, offset);
        intersectTriangle(ts, pts,
                          origins[index],
                          vel[index],
                          Vec3<float>(0, 0, 0),
                          Vec3<float>(X/2, -Y/2, -H),
                          Vec3<float>(-X/2, -Y/2, -H),
                          2, offset);
        intersectTriangle(ts, pts,
                          origins[index],
                          vel[index],
                          Vec3<float>(0, 0, 0),
                          Vec3<float>(-X/2, -Y/2, -H),
                          Vec3<float>(-X/2, Y/2, -H),
                          3, offset);
        intersectTriangle(ts, pts,
                          origins[index],
                          vel[index],
                          Vec3<float>(0, 0, 0),
                          Vec3<float>(-X/2, Y/2, -H),
                          Vec3<float>(X/2, Y/2, -H),
                          4, offset);
        __syncthreads();
    }
}

__global__ void intersectSphere(Vec3<float> *origins, Vec3<float> *vel,
                                const float radius,
                                const int N, float *ts, Vec3<float> *pts)
{
    int index = blockIdx.x * blockDim.x + threadIdx.x;
    // This is done to prevent excess threads from interfering in the code.
    if (index < N)
    {
        /* Calculates the a, b, and c parameters needed for the
         * quadratic formula. These parameters are defined by the
         * equation that is developed by plugging the components
         * of the ray equation for a neutron
         * (<x,y,z> = <x0,y0,z0>+t*<vx,vy,vz>) into the equation of
         * a Sphere.
         */
        float a = (vel[index] | vel[index]);
        float b = 2*(origins[index] | vel[index]);
        float c = (origins[index] | origins[index]);
        c -= radius*radius;
        /* The solveQuadratic function is used to calculate the
         * two potential intersection times. If the function
         * returns false, the neutron does not intersect, and the
         * corresponding values in ts are set to -1.
         */
        float t0, t1;
        if (!solveQuadratic(a, b, c, t0, t1))
        {
            ts[2*index] = -1;
            ts[2*index + 1] = -1;
            return;
        }
        /* If solveQuadratic returns true, the times are stored in 
         * ts, and the intersection points are calculated and stored
         * in pts.
         */
        else
        {
            if (t0 < 0)
            {
                ts[2*index] = -1;
            }
            else
            {
                ts[2*index] = t0;
                pts[2*index] = origins[index] + (vel[index] * t0);
            }
            if (t1 < 0)
            {
                ts[2*index+1] = -1;
            }
            else
            {
                ts[2*index + 1] = t1;
                pts[2*index + 1] = origins[index] + (vel[index] * t1);
            }
        }
        __syncthreads();
    }
}
