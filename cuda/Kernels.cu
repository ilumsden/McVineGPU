#include <cstdio>

#include "Kernels.hpp"

/*__device__ float dot(float ax, float ay, float az,
                     float bx, float by, float bz)
{
    return ax*bx + ay*by + az*bz;
}*/

/*__device__ void cross(float ax, float ay, float az,
                      float bx, float by, float bz,
                      float *cx, float *cy, float *cz)
{
    *cx = ay*bz - az*by;
    *cy = az*bx - ax*bz;
    *cz = ax*by - by*bx;
    return;
}*/

__device__ void intersectRectangle(//float* ts, float* pts,
                                   float* ts, Vec3<float>* pts,
                                   //float x, float y, float z, float zdiff,
                                   const Vec3<float> &orig, float zdiff,
                                   //float va, float vb, float vc, 
                                   const Vec3<float> &vel,
                                   const float A, const float B,
                                   const int key, const int groupSize, 
                                   const int off1, int &off2)
{
    /* Subtracting zdiff from z effectively makes the rectangle
     * be in the same plane as the local (function-specific) XY plane.
     */
    //z -= zdiff;
    // Rework key so that 0->z 1->y 2->x
    float c = orig[2-key] - zdiff;
    /* Calculates t using the basic kinematic equation z1 = z + vz*t
     * Note that z1 is always 0 due to the subtraction above.
     */
    //float t = (0-z)/vc;
    float t = (0-c)/vel[2-key];
    /* Uses the same kinematic equation as above to calculate the local
     * x and y intersection coordinates from the time.
     */
    //float r1x = x+va*t; 
    //float r1y = y+vb*t;
    Vec3<float> pt = orig;
    pt += vel * t;
    int index = blockIdx.x * blockDim.x + threadIdx.x;
    int n1 = (key == 0 || key == 1) ? 0 : 1;
    int n2 = (key == 1 || key == 2) ? 2 : 1;
    // This if-statement ensures the intersection is within the rectangle.
    //if (fabsf(r1x) < (A/2) && fabsf(r1y) < (B/2))
    if (fabsf(pt[n1]) < (A/2) && fabsf(pt[n2]) < (B/2))
    {
        /* The key parameter represents the relationship between this
         * function's local XYZ-coordinate system and the coordinate
         * system of the overall solid. If key is 0, the coordinate
         * systems are the same. If key is 1, the local X matches the
         * solid's Y; the local Y matches the solid's Z; and the local
         * Z matches the solid's X. If key is 2, the local X matches the
         * solid's Z; the local Y matches the solid's X; and the local
         * Z matches the solid's Y.
         * The intersection coordinates in the solid's coordinate system
         * are stored in ix, iy, and iz.
         */
        /*float ix, iy, iz;
        if (key == 0)
        {
            ix = r1x;
            iy = r1y;
            iz = zdiff;
        }
        else if (key == 1)
        {
            iy = r1x;
            iz = r1y;
            ix = zdiff;
        }
        else
        {
            iz = r1x;
            ix = r1y;
            iy = zdiff;
        }*/
        /* This if-statement ensures at most 2 intersection
         * points are stored.
         */
        //if (off2 == 0 || off2 == 3)
        if (off2 < 2)
        {
            // Stores ix, iy, and iz in the pts array.
            /*pts[6*index + off2] = ix;
            pts[6*index + off2 + 1] = iy;
            pts[6*index + off2 + 2] = iz;*/
            pts[2*index + off2] = pt;
            // Increases off2 to prevent data overwrite.
            //off2 += 3;
            off2++;
            //printf("Rectangle: index = %i    off2 = %i\n", index, off2);
        }
        ts[off1 + index*groupSize] = t;
    }
    /* If the intersection coordinates do not fall within the rectangle,
     * a time of -1 is assigned to the function call's element in ts.
     * Additionally, no intersection coordinates are stored in pts.
     */
    else
    {
        ts[off1 + index*groupSize] = -1;
    }
}

__device__ void intersectCylinderSide(//float *ts, float *pts,
                                      float *ts, Vec3<float> *pts,
                                      //float x, float y, float z,
                                      //float vx, float vy, float vz,
                                      const Vec3<float> &orig,
                                      const Vec3<float> &vel,
                                      const float r, const float h, 
                                      int &offset)
{
    /* NOTE: This function is based on the corresponding function
     *       from ArrowIntersector in McVine. As a result, the
     *       solveQuadratic function below is not used here.
     *       It will likely be refactored later to include
     *       said function.
     */
    /* Calculate the a, b, and c parameters for the quadratic formula.
     * The parameters are generated by substituting the x and y
     * components of the neutron's ray equation into the equation for
     * a circular Cylinder. The final equation is:
     *    (vx^2 + vy^2)*t^2 + 2(x*vx + y*vy)*t + (x^2 + y^2 + r^2) = 0
     *
     * Note: The 2 that should be part of b base on the above equation
     *       is not included because it can be combined with the
     *       4 from the 4ac part of the quadratic formula. This combination
     *       is then cancelled by the 2 in the denominator of the
     *       quadratic formula.
     */ 
    float a = vel[0]*vel[0] + vel[1]*vel[1];//vx*vx + vy*vy;
    float b = 2*(orig[0]*vel[0] + orig[1]*vel[1]);//(x*vx + y*vy);
    float c = orig[0]*orig[0] + orig[1]*orig[1] - r*r;//x*x+y*y - r*r; 
    // discr is the discriminant of the quadratic formula (b^2 - 4ac).
    //float discr = b*b - a*c;
    //float t;
    float t0, t1;
    int index = blockIdx.x * blockDim.x + threadIdx.x;
    /* If the discriminant is less than 0, then there are no real roots
     * to the quadratic equation that defines t. As a result, the times
     * in ts are set to the default no-solution value of -1.
     */
    if (!solveQuadratic(a, b, c, t0, t1))
    //if (discr < 0)
    {
        ts[4*index + 2] = -1;
        ts[4*index + 3] = -1;
        //return;
    }
    /* If the discriminant equals 0, there can only be one possible
     * time and, thus, only one possible intersection with the side
     * of the Cylinder.
     */
    else if (t0 < 0)
    //else if (discr == 0)
    {
        /* Calculates time from a simplified, case-specific version of the
         * quadratic formula.
         */
        //t = -b/a;
        /* ts[4*index + 3] stores the time of the second intersection
         * between the neutron and the side of the Cylinder. Since a
         * second intersection is not possible in this case, this element
         * of ts is given a default value of -1.
         */
        ts[4*index + 3] = -1;
        /* The neutron only intersects the side of the Cylinder 
         * if the absolute value of the Z-coordinate of the intersection
         * point is less than h/2.
         */
        //if (fabsf(z+vz*t) < h/2)
        if (fabsf(orig[2]+vel[2]*t1) < h/2)
        {
            ts[4*index + 2] = t1;
            // See intersectRectangle
            //if (offset == 0 || offset == 3)
            if (offset < 2)
            {
                //pts[6*index + offset] = x+vx*t1;
                //pts[6*index + offset + 1] = y+vy*t1;
                //pts[6*index + offset + 2] = z+vz*t1;
                pts[2*index + offset] = orig + (vel*t1);
                //offset += 3;
                offset++;
            }
        }
        else
        {
            ts[4*index + 2] = -1;
        }
    }
    else
    {
        // i is used to track the offset for ts
        int i = 2;
        // t is calculated using the quadratic formula with +
        //discr = sqrtf(discr);
        //t = (-b+discr)/a;
        //if (fabsf(z+vz*t0) < h/2)
        if (fabsf(orig[2]+vel[2]*t0) < h/2)
        {
            ts[4*index + i] = t0;
            i++;
            //if (offset == 0 || offset == 3)
            if (offset < 2)
            {
                //pts[6*index + offset] = x+vx*t0;
                //pts[6*index + offset + 1] = y+vy*t0;
                //pts[6*index + offset + 2] = z+vz*t0;
                pts[2*index + offset] = orig + (vel*t0);
                //offset += 3;
                offset++;
            }
        }
        // t is calculated using the quadratic formula with -
        //t = (-b-discr)/a;
        //if (fabsf(z+vz*t1) < h/2)
        if (fabsf(orig[2]+vel[2]*t1) < h/2)
        {
            ts[4*index + i] = t1;
            i++;
            //if (offset == 0 || offset == 3)
            if (offset < 2)
            {
                //pts[6*index + offset] = x+vx*t1;
                //pts[6*index + offset + 1] = y+vy*t1;
                //pts[6*index + offset + 2] = z+vz*t1;
                pts[2*index + offset] = orig + (vel*t1);
                //offset += 3;
                offset++;
            }
        }
        /* If i < 4, at least one time was not set in ts.
         * This if-statement will set the time of these unset
         * elements to -1.
         */
        if (i < 4)
        {
            for (int j = i; j < 4; j++)
            {
                ts[4*index + j] = -1;
            }
        }
    }
    // Again used to prevent memory corruption
    __syncthreads();
}

__device__ void intersectCylinderTopBottom(//float *ts, float *pts,
                                           float *ts, Vec3<float> *pts,
                                           //float x, float y, float z,
                                           //float vx, float vy, float vz,
                                           const Vec3<float> &orig,
                                           const Vec3<float> &vel,
                                           const float r, const float h,
                                           int &offset)
{
    // Calculates values needed to evaluate and validate the time.
    float r2 = r*r;
    float hh = h/2;
    //float x1, y1;
    Vec3<float> faceint;
    int index = blockIdx.x * blockDim.x + threadIdx.x;
    /* Time is calculated by dividing the Z-distance the neutron has
     * to travel to reach the Z-coordinate of the top of the Cylinder
     * by the Z component of the neutron's velocity.
     */
    //float t = (hh-z)/vz;
    float t = (hh-orig[2])/vel[2];
    /* Uses basic kinematics to determine the X and Y 
     * coordinates of the potential intersection point.
     */
    //x1 = x + vx*t;
    //y1 = y + vy*t;
    faceint = orig + (vel * t);
    /* If the intersection point is a valid solution to the
     * equation defining the circular top of the Cylinder, 
     * the time and intersection coordinates are stored in
     * ts and pts respectively.
     */
    //if (x1*x1 + y1*y1 <= r2)
    if (faceint[0]*faceint[0] + faceint[1]*faceint[1] <= r2)
    {
        ts[4*index] = t;
        //if (offset == 0 || offset == 3)
        if (offset < 2)
        {
            //pts[6*index + offset] = x1;
            //pts[6*index + offset + 1] = y1;
            //pts[6*index + offset + 2] = hh;
            pts[2*index + offset] = faceint;
            //offset += 3;
            offset++;
        }
    }
    // Otherwise, the time is stored as -1.
    else
    {
        ts[4*index] = -1;
    }
    // Repeat the above step for the bottom face of the Cylinder.
    //t = (-hh-z)/vz;
    t = (-hh-orig[2])/vel[2];
    //x1 = x + vx*t;
    //y1 = y + vy*t;
    faceint = orig + (vel * t);
    //if (x1*x1 + y1*y1 <= r2)
    if (faceint[0]*faceint[0] + faceint[1]*faceint[1] <= r2)
    {
        ts[4*index + 1] = t;
        //if (offset == 0 || offset == 3)
        if (offset < 2)
        {
            //pts[6*index + offset] = x1;
            //pts[6*index + offset + 1] = y1;
            //pts[6*index + offset + 2] = hh;
            pts[2*index + offset] = faceint;
            //offset += 3;
            offset++;
        }
    }
    else
    {
        ts[4*index + 1] = -1;
    }
}

/* This function is not yet working.
 * As a result, it will not yet be commented.
 */
__device__ void intersectTriangle(//float *ts, float *pts,
                                  float *ts, Vec3<float> *pts,
                                  //const float x, const float y, const float z,
                                  const Vec3<float> &orig,
                                  //const float vx, const float vy, const float vz,
                                  const Vec3<float> &vel,
                                  //const float aX, const float aY, const float aZ, 
                                  const Vec3<float> &a,
                                  //const float bX, const float bY, const float bZ,
                                  const Vec3<float> &b,
                                  //const float cX, const float cY, const float cZ,
                                  const Vec3<float> &c,
                                  const int off1, int &off2)
{   
    int index = blockIdx.x * blockDim.x + threadIdx.x;
    const float EPSILON = 1e-7;
    Vec3<float> edge1, edge2, h, s, q;
    float z, f, u, v;
    edge1 = b - a;
    edge2 = c - a;
    h = vel * edge2;
    z = edge1 | h;
    if (fabsf(z) < EPSILON)
    {
        ts[5*index + off1] = -1;
        return;
    }
    f = 1/z;
    s = orig - a;
    u = f * (s | h);
    if (u < 0 || u > 1)
    {
        ts[5*index + off1] = -1;
        return;
    }
    q = s * edge1;
    v = f * (vel | q);
    if (v < 0 || u+v > 1)
    {
        ts[5*index + off1] = -1;
        return;
    }
    float t = f * (edge2 | q);
    if (t < EPSILON)
    {
        ts[5*index + off1] = -1;
        return;
    }
    ts[5*index + off1] = t;
    if (off2 < 2)
    {
        pts[2*index + off2] = orig + vel*t;
        off2++;
    }
}

/*__device__ void calculateQuadCoef(float x, float vx, float vy, float vz,
                                  float dist, float &disc,
                                  float &a, float &b, float &c)
{
    a = 1 + (vy/vx)*(vy/vx) + (vz/vx)*(vz/vx);
    b = -2*(1 + ((x*vy*vy)/(vx*vx)) + ((x*vz*vz)/(vx*vx)));
    c = x*x + ((x*vy)/vx)*((x*vy)/vx) + ((x*vz)/vx)*((x*vz)/vx);
    c -= dist*dist;
    disc = b*b - 4*a*c;
    return;
}*/

__device__ bool solveQuadratic(float a, float b, float c, float &x0, float &x1)
{
    // Calculates the discriminant and returns false if it is less than 0.
    float discr = b*b - 4*a*c;
    if (discr < 0)
    {
        return false;
    }
    else
    {
        /* This process ensures that there is little to no roundoff error
         * in the evaluation of the quadratic formula.
         * This process defines a value 
         * q = -0.5 * (b + sign(b)*sqrt(b^2 - 4ac)).
         * If you define x0 = q/a (producing the standard quadratic
         * formula), x1 can be defined as c/q by multiplying the
         * other form of the formula (+/- -> -sign(b)) by
         * ((-b + sign(b)*sqrt(discr))/(-b + sign(b)*sqrt(discr))).
         */
        float q = (b > 0) ? 
                  (-0.5 * (b + sqrtf(discr))) :
                  (-0.5 * (b - sqrtf(discr)));
        x0 = q/a;
        x1 = c/q;
    }
    // This simply ensures that x0 < x1.
    if (x0 > x1)
    {
        float tmp = x0;
        x0 = x1;
        x1 = tmp;
    }
    return true;
}

__global__ void intersectBox(//float* rx, float* ry, float* rz,
                             Vec3<float>* origins,
                             //float* vx, float* vy, float* vz,
                             Vec3<float>* vel,
                             const float X, const float Y, const float Z, 
                             const int N, float* ts, //float* pts)
                             Vec3<float>* pts)
{
    int index = blockIdx.x * blockDim.x + threadIdx.x;
    // This is done to prevent excess threads from interfering in the code.
    if (index < N)
    {
        /* The offset variable is used to ensure only
         * 2 intersection points are recorded.
         */
        int offset = 0;
        /* If the neutron does not move in the Z-direction, there will
         * never be an intersection with the top or bottom. So,
         * the times for top and bottom intersection are set to -1.
         * Otherwise, the intersectRectangle function is used to
         * calculate any potential intersection times and points.
         */
        //if (vz[index] != 0)
        if (vel[index][2] != 0)
        {
            //intersectRectangle(ts, pts, rx[index], ry[index], rz[index], Z/2, vx[index], vy[index], vz[index], X, Y, 0, 6, 0, offset);
            intersectRectangle(ts, pts, origins[index], Z/2, vel[index], X, Y, 0, 6, 0, offset);
            //intersectRectangle(ts, pts, rx[index], ry[index], rz[index], -Z/2, vx[index], vy[index], vz[index], X, Y, 0, 6, 1, offset);
            intersectRectangle(ts, pts, origins[index], -Z/2, vel[index], X, Y, 0, 6, 1, offset);
        }
        else
        {
            ts[index*6] = -1;
            ts[index*6 + 1] = -1;
        }
        /* If the neutron does not move in the X-direction, there will
         * never be an intersection with the sides parallel to the YZ plane.
         * So, the times for these intersections are set to -1.
         * Otherwise, the intersectRectangle function is used to
         * calculate any potential intersection times and points.
         */
        //if (vx[index] != 0)
        if (vel[index][0] != 0)
        {
            //intersectRectangle(ts, pts, ry[index], rz[index], rx[index], X/2, vy[index], vz[index], vx[index], Y, Z, 1, 6, 2, offset);
            intersectRectangle(ts, pts, origins[index], X/2, vel[index], Y, Z, 2, 6, 2, offset);
            //intersectRectangle(ts, pts, ry[index], rz[index], rx[index], -X/2, vy[index], vz[index], vx[index], Y, Z, 1, 6, 3, offset);
            intersectRectangle(ts, pts, origins[index], -X/2, vel[index], Y, Z, 2, 6, 3, offset);
        }
        else
        {
            ts[index*6 + 2] = -1;
            ts[index*6 + 3] = -1;
        }
        /* If the neutron does not move in the Y-direction, there will
         * never be an intersection with the sides parallel to the XZ plane.
         * So, the times for these intersections are set to -1.
         * Otherwise, the intersectRectangle function is used to
         * calculate any potential intersection times and points.
         */
        //if (vy[index] != 0)
        if (vel[index][1] != 0)
        {
            //intersectRectangle(ts, pts, rz[index], rx[index], ry[index], Y/2, vz[index], vx[index], vy[index], Z, X, 2, 6, 4, offset);
            intersectRectangle(ts, pts, origins[index], Y/2, vel[index], Z, X, 1, 6, 4, offset);
            //intersectRectangle(ts, pts, rz[index], rx[index], ry[index], -Y/2, vz[index], vx[index], vy[index], Z, X, 2, 6, 5, offset);
            intersectRectangle(ts, pts, origins[index], -Y/2, vel[index], Z, X, 1, 6, 5, offset);
        }
        else
        {
            ts[index*6 + 4] = -1;
            ts[index*6 + 5] = -1;
        }
    }
}

__global__ void intersectCylinder(//float *rx, float *ry, float *rz,
                                  //float *vx, float *vy, float *vz,
                                  Vec3<float> *origins, Vec3<float> *vel,
                                  const float r, const float h,
                                  const int N, float *ts, //float *pts)
                                  Vec3<float> *pts)
{
    int index = blockIdx.x * blockDim.x + threadIdx.x;
    // This is done to prevent excess threads from interfering in the code.
    if (index < N)
    {
        /* The offset variable is used to ensure only
         * 2 intersection points are recorded.
         */
        int offset = 0;
        /* The actual intersection calculations are carried out
         * by these two helper functions.
         */
        //intersectCylinderTopBottom(ts, pts, rx[index], ry[index], rz[index], vx[index], vy[index], vz[index], r, h, offset);
        intersectCylinderTopBottom(ts, pts, origins[index], vel[index], r, h, offset);
        //intersectCylinderSide(ts, pts, rx[index], ry[index], rz[index], vx[index], vy[index], vz[index], r, h, offset);
        intersectCylinderSide(ts, pts, origins[index], vel[index], r, h, offset);
    }
}

__global__ void intersectPyramid(//float *rx, float *ry, float *rz,
                                 //float *vx, float *vy, float *vz,
                                 Vec3<float> *origins, Vec3<float> *vel,
                                 const float X, const float Y, const float H,
                                 const int N, float *ts, //float *pts)
                                 Vec3<float> *pts)
{
    int index = blockIdx.x * blockDim.x + threadIdx.x;
    // This is done to prevent excess threads from interfering in the code.
    if (index < N)
    {
        /* The offset variable is used to ensure only
         * 2 intersection points are recorded.
         */
        int offset = 0;
        /* If the neutron doesn't move in the Z-direction, it will
         * never intersect the Pyramid's base. If it might intersect,
         * the intersectRectangle function is used to determine any
         * intersection point.
         */
        //if (vz[index] != 0)
        if (vel[index][2] != 0)
        {
            //intersectRectangle(ts, pts, rx[index], ry[index], rz[index], -H, vx[index], vy[index], vz[index], X, Y, 0, 5, 0, offset);
            intersectRectangle(ts, pts, origins[index], -H, vel[index], X, Y, 0, 5, 0, offset);
        }
        /* These calls to intersectTriangle determine if there are
         * any intersections between the neutron and the triangular
         * faces of the Pyramid.
         */
        //intersectTriangle(ts, pts,
        //                  rx[index], ry[index], rz[index],
        //                  vz[index], vy[index], vz[index],
        //                  0, 0, 0, X/2, Y/2, -H, X/2, -Y/2, -H,
        //                  1, offset);
        intersectTriangle(ts, pts,
                          origins[index],
                          vel[index],
                          Vec3<float>(0, 0, 0),
                          Vec3<float>(X/2, Y/2, -H),
                          Vec3<float>(X/2, -Y/2, -H),
                          1, offset);
        //intersectTriangle(ts, pts,
        //                  rx[index], ry[index], rz[index],
        //                  vz[index], vy[index], vz[index],
        //                  0, 0, 0, X/2, -Y/2, -H, -X/2, -Y/2, -H,
        //                  2, offset);
        intersectTriangle(ts, pts,
                          origins[index],
                          vel[index],
                          Vec3<float>(0, 0, 0),
                          Vec3<float>(X/2, -Y/2, -H),
                          Vec3<float>(-X/2, -Y/2, -H),
                          2, offset);
        //intersectTriangle(ts, pts,
        //                  rx[index], ry[index], rz[index],
        //                  vz[index], vy[index], vz[index],
        //                  0, 0, 0, -X/2, -Y/2, -H, -X/2, Y/2, -H,
        //                  3, offset);
        intersectTriangle(ts, pts,
                          origins[index],
                          vel[index],
                          Vec3<float>(0, 0, 0),
                          Vec3<float>(-X/2, -Y/2, -H),
                          Vec3<float>(-X/2, Y/2, -H),
                          3, offset);
        //intersectTriangle(ts, pts,
        //                  rx[index], ry[index], rz[index],
        //                  vz[index], vy[index], vz[index],
        //                  0, 0, 0, -X/2, Y/2, -H, X/2, Y/2, -H,
        //                  4, offset);
        intersectTriangle(ts, pts,
                          origins[index],
                          vel[index],
                          Vec3<float>(0, 0, 0),
                          Vec3<float>(-X/2, Y/2, -H),
                          Vec3<float>(X/2, Y/2, -H),
                          4, offset);
        __syncthreads();
        //printf("index = %i:\n    ts[%i] = %f ts[%i] = %f ts[%i] = %f ts[%i] = %f ts[%i] = %f\n    rx[%i] = %f ry[%i] = %f rz[%i] = %f\n    vx[%i] = %f vy[%i] = %f vz[%i] = %f\n    pts[%i] = %f pts[%i] = %f pts[%i] = %f\n    pts[%i] = %f pts[%i] = %f pts[%i] = %f\n", index, 5*index, ts[5*index], 5*index+1, ts[5*index+1], 5*index+2, ts[5*index+2], 5*index+3, ts[5*index+3], 5*index+4, ts[5*index+4], index, rx[index], index, ry[index], index, rz[index], index, vx[index], index, vy[index], index, vz[index], 6*index, pts[6*index], 6*index+1, pts[6*index+1], 6*index+2, pts[6*index+2], 6*index+3, pts[6*index+3], 6*index+4, pts[6*index+4], 6*index+5, pts[6*index+5]);
    }
}

__global__ void intersectSphere(//float *rx, float *ry, float *rz,
                                //float *vx, float *vy, float *vz,
                                Vec3<float> *origins, Vec3<float> *vel,
                                const float radius,
                                const int N, float *ts, //float *pts)
                                Vec3<float> *pts)
{
    int index = blockIdx.x * blockDim.x + threadIdx.x;
    // This is done to prevent excess threads from interfering in the code.
    if (index < N)
    {
        /* Calculates the a, b, and c parameters needed for the
         * quadratic formula. These parameters are defined by the
         * equation that is developed by plugging the components
         * of the ray equation for a neutron
         * (<x,y,z> = <x0,y0,z0>+t*<vx,vy,vz>) into the equation of
         * a Sphere.
         */
        float a = (vel[index] | vel[index]);//dot(vx[index], vy[index], vz[index],
                      //vx[index], vy[index], vz[index]);
        float b = 2*(origins[index] | vel[index]);//2 * dot(rx[index], ry[index], rz[index],
                          //vx[index], vy[index], vz[index]);
        float c = (origins[index] | origins[index]);//dot(rx[index], ry[index], rz[index],
                      //rx[index], ry[index], rz[index]);
        c -= radius*radius;
        /* The solveQuadratic function is used to calculate the
         * two potential intersection times. If the function
         * returns false, the neutron does not intersect, and the
         * corresponding values in ts are set to -1.
         */
        float t0, t1;
        if (!solveQuadratic(a, b, c, t0, t1))
        {
            ts[2*index] = -1;
            ts[2*index + 1] = -1;
            return;
        }
        /* If solveQuadratic returns true, the times are stored in 
         * ts, and the intersection points are calculated and stored
         * in pts.
         */
        else
        {
            if (t0 < 0)
            {
                ts[2*index] = -1;
            }
            else
            {
                ts[2*index] = t0;
                //pts[6*index] = rx[index] + vx[index] * t0;
                //pts[6*index+1] = ry[index] + vy[index] * t0;
                //pts[6*index+2] = rz[index] + vz[index] * t0;
                pts[2*index] = origins[index] + (vel[index] * t0);
            }
            if (t1 < 0)
            {
                ts[2*index+1] = -1;
            }
            else
            {
                ts[2*index + 1] = t1;
                //pts[6*index+3] = rx[index] + vx[index] * t1;
                //pts[6*index+4] = ry[index] + vy[index] * t1;
                //pts[6*index+5] = rz[index] + vz[index] * t1;
                pts[2*index + 1] = origins[index] + (vel[index] * t1);
            }
        }
        __syncthreads();
    }
}

__global__ void simplifyTimes(const float *times, const int N, const int groupSize, float *simp)
{
    int index = blockIdx.x * blockDim.x + threadIdx.x;
    // This is done to prevent excess threads from interfering in the code.
    if (index < N)
    {
        int count = 0;
        for (int i = 0; i < groupSize; i++)
        {
            if (times[groupSize * index + i] != -1 && count < 2)
            {
                simp[2*index+count] = times[groupSize*index+i];
                count++;
            }
        }
    }
}

__global__ void prepRand(curandState *state, int seed)
{
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    curand_init(((seed << 10) + idx), 0, 0, &state[idx]); 
}

__device__ void randCoord(//float* inters, float* time, 
                          //float *sx, float *sy, float *sz, 
                          Vec3<float> *inters, float *time,
                          Vec3<float> &pos,
                          curandState *state)
{
    int index = blockIdx.x * blockDim.x + threadIdx.x;
    /* Instead of pasing the initial ray data, the two intersection
     * points and times are used to recalculate the velocities.
     */
    float dt = time[1] - time[0];
    //float mx = (inters[3] - inters[0])/dt;
    //float my = (inters[4] - inters[1])/dt;
    //float mz = (inters[5] - inters[2])/dt;
    Vec3<float> m = (inters[1] - inters[0]) * (1.0/dt);
    // cuRand is used to generate a random time between 0 and dt.
    float randt = curand_uniform(&(state[index]));
    randt *= dt;
    /* Basic kinematics are used to calculate the coordinates of
     * the randomly chosen scattering site.
     */
    pos = inters[0] + (m*randt);
    //*sx = inters[0] + mx*randt;
    //*sy = inters[1] + my*randt;
    //*sz = inters[2] + mz*randt;
}

__global__ void calcScatteringSites(//float* ts, float* int_pts, 
                                    //float* pos, curandState *state, 
                                    float *ts, Vec3<float> *int_pts,
                                    Vec3<float> *pos, curandState *state,
                                    const int N)
{
    int index = blockIdx.x * blockDim.x + threadIdx.x;
    // This is done to prevent excess threads from interfering in the code.
    if (index < N)
    {
        /* If the intersection times for the neutron are the default
         * value of -5, there was no intersection, so the function
         * terminates.
         */
        if (ts[2*index] != -5 && ts[2*index+1] != -5)
        {
            /* The randCoord function assumes that the first time
             * is smaller than the second. If this is not the
             * case, the times and the corresponding intersection
             * coordinates are swapped.
             */
            if (ts[2*index] > ts[2*index+1])
            {
                float tmpt;//, tmpc;
                Vec3<float> tmpv;
                tmpt = ts[2*index];
                ts[2*index] = ts[2*index+1];
                ts[2*index+1] = tmpt;
                tmpv = int_pts[2*index];
                int_pts[2*index] = int_pts[2*index+1];
                int_pts[2*index+1] = tmpv;
                /*for (int i = 6*index; i < 6*index+3; i++)
                {
                    tmpc = int_pts[i];
                    int_pts[i] = int_pts[i + 3];
                    int_pts[i + 3] = tmpc;
                }*/
            }
            /* The randCoord function is called to determine the
             * scattering site.
             */
            //randCoord(&(int_pts[6*index]), &(ts[2*index]), &(pos[3*index + 0]), &(pos[3*index + 1]), &(pos[3*index + 2]), state);
            randCoord(&(int_pts[2*index]), &(ts[2*index]), pos[index], state);
        }
    }
}
